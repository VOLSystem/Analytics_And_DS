---
title: "Music Recommendation Case"
author: "You"
date: "November 20, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(arules)
library(arulesViz)
library(stringi)

extract_sides <- function(RULES) {
  DF <- as(RULES,"data.frame")
  DF$rules <- as.character(DF$rules)
  TEMP <- strsplit(DF$rules, "[[:punct:][:space:]]+")
  TEMP <- lapply(TEMP,function(x)x[-1]) 
  DF$rhs <- unlist( lapply(TEMP,function(x)tail(x,1) ) )
  TEMP <- lapply(TEMP,function(x)x[-length(x)])
  newcolumns <- max( unlist(lapply(TEMP,length) ) )
  for (i in 1:newcolumns) { 
    DF <- cbind(DF, unlist( lapply(TEMP,function(x)x[i] ) ) ) 
    DF[,ncol(DF)] <- as.character(DF[,ncol(DF)])
  }
  DF <- data.frame(DF[,seq(ncol(DF)-newcolumns+1,by=1,length=newcolumns)], DF$rhs, DF$support, DF$confidence, DF$lift,stringsAsFactors = FALSE)
  names(DF)[-(1:newcolumns)] <- c("rhs","support","confidence","lift")
  if(newcolumns>1) { names(DF)[(1:newcolumns)] <- paste("lhs",1:newcolumns,sep="") } else { names(DF)[1] <- "lhs" }
  
  return(DF)
}
```

## Overview

The year was 2011.  Lady Antebellum won Record of the Year with "Need You Know", while Lady Gaga had her "Fame Monster" album nominated for Album of the Year.  Justin Bieber, Drake, and Florence and the Machine were nominated for best new artist.  Streaming music services were quickly gaining traction, with Spotify having over 6 million users outside the US (Spotify launched their US service in 2011 as well).  In fact, Spotify scored an exclusive deal with Facebook to be the "default music service" of Facebook.

Previously, streaming services like Pandora "picked" songs for you based on what it anticipated to be songs you would potentially like, throwing in some bizarre choices every now and then because "you never know".  The face of the music industry would never be the same.

Pandora, Netflix, amazon, etc., have developed recommendation engines that take your viewing and rating history and suggest new songs/shows/movies/products that you might like.   In fact many places do this, and for products as well.   For instance, amazon.com has a "Frequently Bought Together", imdb.com has a "People who liked this also liked...", Netflix has a "More like this", Bestbuy has a "Customers who viewed this item also viewed", Walmart.com has a "Customers also considered" section to all of their product pages. 

The broadest term for this type of an analysis is "market basket analysis" and the techniques are called "association rule learning".  For example, see

http://snowplowanalytics.com/guides/recipes/catalog-analytics/market-basket-analysis-identifying-products-that-sell-well-together.html

http://www.albionresearch.com/data_mining/market_basket.php

https://en.wikipedia.org/wiki/Association_rule_learning

http://kb.tableau.com/articles/knowledgebase/market-basket-analysis

In this case, you will get practice developing a recommendation engine for music artists using publicly available data about nearly 2000 users' listening habits on Last.fm.

## Last.fm

Last.fm is a music website (https://www.last.fm/) founded in the United Kingdom in 2002. Using a music recommender system called "Audioscrobbler", Last.fm builds a detailed profile of each user's musical taste by recording details of the tracks the user listens to, either from Internet radio stations, or the user's computer or many portable music devices. This information is transferred ("scrobbled") to Last.fm's database either via the music player itself (including, among others Spotify, Deezer, Tidal, and MusicBee) or via a plugin installed into the user's music player. The data is then displayed on the user's profile page and compiled to create reference pages for individual artists.

On 30 May 2007, it was acquired by CBS Interactive for UKÂ£140 million (US$280 million).  The site formerly offered a radio streaming service, which was discontinued on 28 April 2014. The ability to access the large catalog of music stored on the site was later removed entirely, replaced by links to YouTube and Spotify where available. 

## Data

You are provided with information about the listening habits of 1860 users of Last.fm and the nearly 100,000 artists they have listened to (http://files.grouplens.org/datasets/hetrec2011/hetrec2011-lastfm-2k.zip).  There is a wealth of information contained here including social networking data and tagging, but we will focus on which users listed to which artists.

The dataset is released in the framework of the 2nd International Workshop on Information Heterogeneity and Fusion in Recommender Systems (HetRec 2011; http://ir.ii.uam.es/hetrec2011) at the 5th ACM Conference on Recommender Systems (RecSys 2011; http://recsys.acm.org/2011).  The data was released in May 2011, a bit dated by today's standards, but it reflects the music landscape of that time.



Each viewer has a record of the number of 17 episodes of 784 different television shows (anonymized to be Show1 to Show784).  These values are determined by "set meters" and include "time-shifted" viewings on DVRs.  Fractional values are possible when the viewer tuned in for only part of one or more episodes.   


## Assignment and Grading

The goal of this project is to write a recommendation engine that has the following form

```{r recommend, eval=FALSE}
recommend <- function(likes,TRANS,number,innovations=0,innovation.prob=0.5,min.listeners=50,max.length=5) {
  require(arules)  #this loads up arules if it is not already loaded
}
```

* `likes` - a vector of musical artists, e.g., `c("MileyCyrus","BlackEyedPeas","KylieMinogue","Shakira","LadyGaga")`

* `TRANS` - a transactional object

* `number` - a number telling how many recommendations to return

* `innovations` - a number telling how many "innovative" recommendations to return; the intention is to recommend lesser-known artists that the user might like even if they have a relatively low level of confidence

* `innovation.prob` - the minimum confidence level associated with a recommendation of an "innovative" recommendation

* `min.listeners` - used to calculated the minimum support of a rule, i.e., the rule has to apply to at least `min.listeners/length(TRANS)` people

* `max.length` - the maximum "length" of the rule.  A rule of length 5 has the form "if A, B, C, D, then E"

Note:  you will build the ruleset from within the function and do all manipulation of it inside as well.  The function will return a character vector.  The first `number` elements will be the recommendations with the highest level of confidence.  The remaining `innovations` elements will be recommendations that were picked at random from the remaining rules.  


Grading will proceed by trying out your recommendation on a few sets of `likes` vectors.  At most 4 artists will be in this `likes` vector, so you only need to consider rules of length 5 or less.  However, `innovation.prob` will be test down to values of 0.5, so the rules you find should have a minimum value of confidence of no less than 50%.  Finally, take the support of your ruleset to be at least 40/1860 (so that all rules found will apply to at least 40 listeners).


## Preliminary data cleaning and rule making

The original data is not in "transactional form" (one line per listener with artists separated by commas), so some work is necessary to get there.  You can feel free to use this code verbatim, which is commented and narrated.

One "design choice" is that I decided to eliminate any artist associated with a listener that had a "weight" of 20 or less.  The weight is a relative measure of how big a fan the listener is of that artist (the company has an algorithm to determine this based on play frequency and other factors).  In general, it would be up to you to pick a more sensitive value according to what exactly you want out of the recommendation engine, but for grading purposes please leave this at 20.

```{r cleaning}
#Read in artists file to "deanonymize" music habits; treat them as characters not categorical variable
ARTISTS <- read.csv("artistsprop.csv",stringsAsFactors = FALSE)
names(ARTISTS)[1] <- "id"   ###Change from original version
#Read in listeners habits
MUSIC <- read.table("user_artists.dat",head=TRUE)
#Go through each userID and find all artists to whom listeners gives a weight of at least 20 
#Replace artist ID by actual artist, then eliminate all non letters/numbers, then create
#a comma separated line of text which will be written to the file musiclikes.csv
#The first time this is done, the file is created/overwritten.  Subsequent calls to write
#append lines to the file.
for (i in unique(MUSIC$userID)) {
  S <- subset(MUSIC,userID==i & weight > 20)
  if(nrow(S)==0) { next } 
  artists <- ARTISTS[match(S$artistID,ARTISTS$id),"name"]
  artists <- unlist( lapply( stri_extract_all_regex(artists, "[A-Za-z0-9]+"),function(x)paste(x,collapse="") ) )
  artists <- subset(artists,artists != "NA" )
  if( i == unique(MUSIC$userID)[1] )  { 
  write(artists,ncolumns=length(artists),sep=",",file="musiclikes.csv") } else {
      write(artists,ncolumns=length(artists),append=TRUE,sep=",",file="musiclikes.csv")
  }
}
```

The new data file `musiclikes.csv` is in transactional form (one line per listener, comma-separated items), so `read.transactions` can be used to read it in, and you are ready to start building rules.

```{r reading in data}
library(arules)
TRANS <- read.transactions("musiclikes.csv",sep=",",format="basket")
inspect(TRANS[1:10])  #look at first 10 listeners
tail( sort( itemFrequency(TRANS) ), 20 )  #20 most commonly listened-to artists
head( sort( itemFrequency(TRANS) ), 20 )  #20 least commonly listend-to artists
```


Now it's time to write you function!  

The following example proceeds for a very particular case with 6 of my favorite bands back in 2011.  Confirm that you produce the same set of recommendations (all good choices).  Code is narrated.  My method for determining the probabilities that each "innovation" is picked is just my own creation.  It's fine if you just have it randomly select from the remaining recommendations with equal probabilities, in which case you leave out the `prob` argument of `sample`.

```{r rule discovery}

likes <- c("ABBA","Prince","TheCure","Rush","PinkFloyd","Adele","KellyClarkson")

likes <- c('TheAllAmericanRejects','RobbieWilliams','TheProdigy','VanessaHudgens','AliceinChains')

#Fit rules according to the specified parameters
RULES <- apriori(TRANS,
                 parameter = list(
                   supp=40/length(TRANS),
                   conf=0.5,maxlen=5),
                 appearance = list(lhs=likes,default="rhs"),
                 control=list(verbose=FALSE))
#Look at the rules
inspect(RULES)
#Convert RULES object into a dataframe for easier manipulation
R <- extract_sides(RULES)
#Make a dataframe containing the RHS of the recommendation and its level of confidence
RECOMMENDATION <- data.frame(rhs=R$rhs,confidence=R$confidence,stringsAsFactors = FALSE)

#Sort by confidence, highest up on top  (this is new compared to class)
RECOMMENDATION <- RECOMMENDATION[order(RECOMMENDATION$confidence,decreasing=TRUE),]

#Remove duplicate recommendations (many rules could recommend the same artist)
RECOMMENDATION <- RECOMMENDATION[!duplicated(RECOMMENDATION$rhs),]
#Remove recommendations that are bands in the listener's list of likes
RECOMMENDATION <- subset(RECOMMENDATION,rhs %in% setdiff(RECOMMENDATION$rhs,likes ))
#Create a vector of the top 3 of recommendations
top.picks <- RECOMMENDATION$rhs[1:3]

#Now pick the innovations.  Let the probabilities of each be proportional to 1/support^2
pick.prob <- (as.numeric( 1/itemFrequency(TRANS)[RECOMMENDATION$rhs[-(1:3)]] ))^2
set.seed(479); potential.picks <- sample(RECOMMENDATION$rhs[-(1:3)],2,prob=pick.prob)
c(top.picks,potential.picks)

#First vector of likes
#"ChristinaAguilera" "Rihanna"           "BritneySpears"     "TheBeatles"        "DepecheMode"   


#Second vector of likes
#[1] "Rihanna"           "BritneySpears"     "ChristinaAguilera" "Madonna"           "AshleyTisdale"     

```

Now adapt that code so that it works inside of a function.  You'll have to worry about a few complications:

*DONE What if the `RECOMMENDATION` dataframe comes up with no recommendations?  Have it output an error message that lets you know when that happens with `stop()`, i.e. `if(length(RULES)==0) { stop() }`

*DONE What if `number` happens to be larger than the number of recommendations that can be made?  You'll need to figure out how to make sure the function doesn't crash if that's the case.  Have it output a warning message when that happens, i.e. `if(number>length(RULES)) { warning() }`.

* What if `innovations` is "too big".  In other words, there aren't enough recommendations left over to suggest any "innovative" pics?  You'll need to make sure the code doesn't crash in this case, but do have it output a warning message when that happens.

* If `innovations` equals 0, you don't have to worry about the last bullet point.

There are 4 test cases below that your code should handle.  In other words, your function shouldn't crash unexpectedly when evaluating the four vectors of `likes` below (one gives a custom error when there were no recommendations to make)

```{r rule creation}


recommend <- function(likes,TRANS,number=5,innovations=5)
RULES <- apriori(TRANS,
                 parameter = list(
                   supp=40/length(TRANS),
                   conf=0.5,maxlen=5),
                 appearance = list(lhs=likes,default="rhs"),
                 control=list(verbose=FALSE))
#If there are no recommendations
if(length(RULES)==0) {stop(print("Sorry, we couldn't find any recommendations that you might like =("))}


#Convert RULES object into a dataframe for easier manipulation
R <- extract_sides(RULES)
#Make a dataframe containing the RHS of the recommendation and its level of confidence
RECOMMENDATION <- data.frame(rhs=R$rhs,confidence=R$confidence,stringsAsFactors = FALSE)

#Sort by confidence, highest up on top  (this is new compared to class)
RECOMMENDATION <- RECOMMENDATION[order(RECOMMENDATION$confidence,decreasing=TRUE),]

#Remove duplicate recommendations (many rules could recommend the same artist)
RECOMMENDATION <- RECOMMENDATION[!duplicated(RECOMMENDATION$rhs),]
#Remove recommendations that are bands in the listener's list of likes
RECOMMENDATION <- subset(RECOMMENDATION,rhs %in% setdiff(RECOMMENDATION$rhs,likes ))

if(number<=(length(RULES))){
#Create a vector of the top requested number of recommendations
top.picks <- RECOMMENDATION$rhs[1:number]
}else{
  top.picks <- RECOMMENDATION$rhs[1:length(RULES)]
  stop(print("Sorry, you asked for too many recommendations. Please try again."))
}


if(length(RECOMMENDATION)>=(number+innovations)){
#Now pick the innovations.  Let the probabilities of each be proportional to 1/support^2
pick.prob <- (as.numeric( 1/itemFrequency(TRANS)[RECOMMENDATION$rhs[-(1:3)]] ))^2
set.seed(479); potential.picks <- sample(RECOMMENDATION$rhs[-(1:number)],2,prob=pick.prob)
c(top.picks,potential.picks)
}else{
  top.picks
  stop(print("No additional recommendations available."))
}








```





```{r solutions}
recommend <- function(likes,TRANS,number,innovations=0,innovation.prob=0.5,min.listeners=50,max.length=5) {
  require(arules)  #this loads up arules if it is not already loaded
  extract_sides <- function(RULES) {
  DF <- as(RULES,"data.frame")
  DF$rules <- as.character(DF$rules)
  TEMP <- strsplit(DF$rules, "[[:punct:][:space:]]+")
  TEMP <- lapply(TEMP,function(x)x[-1]) 
  DF$rhs <- unlist( lapply(TEMP,function(x)tail(x,1) ) )
  TEMP <- lapply(TEMP,function(x)x[-length(x)])
  newcolumns <- max( unlist(lapply(TEMP,length) ) )
  for (i in 1:newcolumns) { 
    DF <- cbind(DF, unlist( lapply(TEMP,function(x)x[i] ) ) ) 
    DF[,ncol(DF)] <- as.character(DF[,ncol(DF)])
  }

  
}
}


#Not enough recommendations can be made based on "number"
likes <- c('DevinTownsendProject','LinkinPark','Travis','NeuroticOutsiders','MammaMiaFilmCast','DepecheMode','Cursed','Wire','deadmau5','Lrm')
recommend(likes,TRANS,number=5,innovations=1,innovation.prob=0.5,min.listeners=20,max.length=5)
#[1] "Radiohead" "Coldplay" 
#Warning messages:
#1: In recommend(likes, TRANS, number = 5, innovations = 1, innovation.prob = 0.5,  :
#  Number of recommendations less than what is requested
#2: In recommend(likes, TRANS, number = 5, innovations = 1, innovation.prob = 0.5,  :
#  Number of innovations less than what is requested


#No recommendations to make
likes <- c("AphexTwin","ZuzanaSmatanov")
recommend(likes,TRANS,number=5,innovations=1,innovation.prob=0.5,min.listeners=20,max.length=5)
#Error in recommend(likes, TRANS, number = 5, innovations = 1, innovation.prob = 0.5,  : 
#  No recommendations to make

#No innovations requested (shouldn't output error or warning)
likes <- c("BritneySpears","Pnk")
recommend(likes,TRANS,number=3,innovations=0,max.length=5)
#"ThePussycatDolls" "Shakira"          "Rihanna"       

#Too many innovations requested
likes <- c('TheAllAmericanRejects','RobbieWilliams','TheProdigy','VanessaHudgens','AliceinChains')
recommend(likes,TRANS,number=8,innovations=5,max.length=5)
# [1] "Rihanna"           "MileyCyrus"        "LadyGaga"          "KellyClarkson"     "Keha"              "KatyPerry"        
# [7] "ChristinaAguilera" "BritneySpears"     "AvrilLavigne"      "AshleyTisdale"     "Beyonc"           
#Warning message:
#In recommend(likes, TRANS, number = 8, innovations = 5, max.length = 5) :
#  Number of innovations less than what is requested


#Should work just fine
likes <- c("ABBA","Prince","TheCure","Rush","PinkFloyd","Adele","KellyClarkson")
recommend(likes,TRANS,number=8,innovations=5,max.length=5)
# [1] "TheBeatles"        "TaylorSwift"       "Shakira"           "Rihanna"           "Pnk"               "MileyCyrus"       
# [7] "Madonna"           "LadyGaga"          "BritneySpears"     "DepecheMode"       "Keha"              "KatyPerry"        
#[13] "ChristinaAguilera"

#Should work just fine
likes <- c('TheAllAmericanRejects','RobbieWilliams','TheProdigy','VanessaHudgens','AliceinChains')
recommend(likes,TRANS,number=4,innovations=3,max.length=5)
#[1] "Rihanna"       "MileyCyrus"    "LadyGaga"      "KellyClarkson" "BritneySpears" "AshleyTisdale" "Keha"         
```
